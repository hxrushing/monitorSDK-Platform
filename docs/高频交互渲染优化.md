## 高频缩放与拖拽交互的渲染优化实践（结合当前项目）

### 背景与目标
- 场景：图表/画布在持续缩放、拖拽、平移等高频交互下保持 60fps 体验。
- 目标：降低主线程阻塞与重绘次数，缩短交互到可见反馈的时延，避免内存与 GPU 峰值。

### 本项目的场景映射
- 前端栈：React + Ant Design + `@ant-design/plots`（懒加载），部分图表使用 Web Worker 下沉计算。
- 高频交互场景：事件分析页的折线图缩放/拖拽；仪表盘中多图联动；大数据采样与渲染（10w+ 点）。
- 已有能力：
  - `src/hooks/useWorker.ts` + `workers/dataSampling.worker.ts`：自适应采样（LTTB + 最大最小）在 Worker 中执行。
  - `src/utils/dataSampling.ts`：前端同步降采样的兜底实现。
  - `EventAnalysis` 页面：懒加载图表、`useMemo`/`useCallback` 减少重渲染、数据量阈值判定后切换 Worker 采样。
  - 文档参考：`docs/LTTB算法在数据可视化中的应用.md`、`docs/时间窗口聚合与自适应采样策略设计与实现说明.md`。

### 常见瓶颈
- 主线程：布局/重排、过量事件回调、同步计算和大对象拷贝。
+- 绘制：重复全量重绘、像素填充过大、抗锯齿和阴影等高成本效果。
+- 数据：大规模点/线数据（10w+）在缩放时的重新采样与映射开销。
+- GPU/内存：纹理过大、频繁创建销毁 buffer、离屏与主屏间的频繁 copy。

### 优化手段（按优先级）
1) **事件侧降频与合并**
   - 使用 `pointermove`/`wheel` 节流（例如 8–16ms）或基于 `requestAnimationFrame` 的采样：仅在下一帧渲染前读取最新交互状态，丢弃中间帧。
   - 将多次微小位移合并为一次累计位移，减少渲染提交次数。

2) **渲染节流与增量绘制**
   - 以帧为单位提交渲染：在 `rAF` 中读取「最新状态快照」，保持 1 次绘制/帧。
   - 增量重绘：仅重绘受影响区域（dirty rect），避免全画布重绘。
   - 双缓冲/离屏画布：在离屏合成后一次性呈现，减少闪烁和部分绘制可见。

3) **视口裁剪与数据降采样**
   - 视口裁剪：仅渲染可见范围的图形元素；列表/节点采用虚拟化。
   - 动态降采样：缩放或快速拖拽时启用快速简化（如 LTTB/最大最小采样），在交互停止后再渲染精细版本。
   - 分辨率自适应：缩放过程中临时降低分辨率/像素密度，静止后恢复高清。

4) **计算卸载与并行**
   - 将坐标映射、采样、布局等重计算放入 Web Worker，主线程仅收取结果并绘制。
   - 使用 `transferable`/`SharedArrayBuffer` 避免大数据复制；保持结构体扁平化。

5) **GPU 优化（如使用 WebGL/WebGPU）**
   - 预分配并复用 VBO/IBO/纹理，避免频繁创建销毁。
   - 批量绘制：合并 draw call，使用实例化绘制重复图元。
   - 降低片元填充：控制点大小/线宽、关闭高成本后处理；必要时启用 scissor/stencil 限制绘制区域。

6) **调度与优先级**
   - 交互路径优先：交互相关的状态更新与绘制放在高优先级队列，延后非关键任务（标注、动画、统计）。
   - 时间切片：将耗时计算拆分为小块跨帧执行，避免超过 16ms。

7) **内存与对象管理**
   - 复用 TypedArray/对象池，避免频繁 GC；谨慎保留快照，及时释放离屏资源。
   - 使用轻量数据结构（索引+缓冲）而非深层对象。

### 在本项目的落地要点
- 事件分析页（`src/pages/EventAnalysis`）：
  - 已用懒加载图表，保持首屏轻；`useMemo`/`useCallback` 降低重渲染。
  - 采样策略：数据量 ≤ 500 直接渲染，> 500 优先通过 `useDataSamplingWorker` 将采样放入 Worker，失败时回退到 `adaptiveChartSampling` 同步实现。
  - 建议补充：在缩放/拖拽时用 `requestAnimationFrame` 合并状态，图表层只消费最新状态；对超大数据集增加「快速降采样 + 交互停止后精细重绘」的双阶段逻辑。
- 时间窗口聚合 + 自适应采样（与采样文档联动）：
  - 后端有条件时：按像素驱动的 `windowSize = N / (W * k)` 做 min/max/avg 聚合，再返回 LTTB 采样后的千级数据；前端直接渲染，减少传输与主线程计算。
  - 后端未改造时：在 Worker 内先时间窗口聚合再跑 LTTB，避免主线程阻塞；`maxPoints` 按图表宽度与设备性能动态设定（桌面 1k~2k，移动 300~800）。
  - 多图联动：复用同一批采样结果，防止每个图重复采样；缩放时请求/计算对应 zoom 粒度的数据，停下后再切换为精细采样。
- Worker 能力（`workers/dataSampling.worker.ts` + `useWorker`）：
  - 继续复用 TypedArray 传输，避免重复分配；大数据场景采用 `postMessage` 的 transferable。
  - 建议在 Worker 内增加时间切片（分批处理）与取消标记，避免长任务阻塞返回。
- 渲染层（`@ant-design/plots`）：
  - 尝试开启/保留 viewport 裁剪选项；对折线/面积图控制点大小、阴影开关，降低片元填充。
  - 若有联动多图，使用统一的 rAF 调度合并多次交互触发的渲染。
- 监控与压测：
  - 在开发/测试环境加入简单 FPS Overlay 与事件采样日志，确认缩放/拖拽时 P95 帧时长 < 16ms。
  - 使用脚本化高频交互压测（可复用 `server/test_sdk_performance.js` 的思路）覆盖低端机型与高分屏。

### 关键策略示例
```javascript
// 基于 rAF 的事件合并与增量绘制
let pending = false;
let latestState = { zoom: 1, dx: 0, dy: 0 };

canvas.addEventListener('wheel', (e) => {
  latestState.zoom *= 1 + e.deltaY * -0.001;
  schedule();
});

canvas.addEventListener('pointermove', (e) => {
  if (e.buttons & 1) {
    latestState.dx += e.movementX;
    latestState.dy += e.movementY;
    schedule();
  }
});

function schedule() {
  if (pending) return;
  pending = true;
  requestAnimationFrame(() => {
    pending = false;
    render(latestState); // 在渲染中仅使用最新状态，丢弃中间帧
  });
}
```

### 监控与回归保障
- 指标：帧时长分布 (P50/P95)、掉帧率、输入到像素时延 (INP)、内存/纹理占用。
- 可观测性：在开发版启用 FPS overlay、渲染耗时分段日志（采样上报），记录降采样/降分辨率触发次数。
- 压测：脚本化高频缩放/拖拽，覆盖大数据量和极端设备（低端 GPU/高分屏）。

### 实施建议
- 先做事件合并 + rAF 渲染节流，确认帧率回到目标区间。
- 再加入视口裁剪与降采样，控制数据规模与像素填充。
- 需要更大提升时，引入 GPU 路径和 Worker 计算卸载。
- 持续用指标回归，确保优化不会影响静态清晰度与正确性。

