## 时间窗口聚合与自适应采样策略设计与实现说明

> 本文档面向前后端开发同学，说明在大规模时间序列数据可视化中，如何利用**时间窗口聚合**与**自适应采样（以 LTTB 为代表）**提升性能、降低内存，并给出典型使用场景与实现建议。

---

### 一、背景与目标

- **问题背景**
  - 在监控大盘、行为分析、预测结果展示等场景中，前端常需要展示 **10 万～100 万级** 的时间序列数据点。
  - 如果直接把全部点交给图表组件渲染，会遇到：
    - **渲染时间长**：Canvas / SVG / WebGL 绘制开销巨大，页面卡顿；
    - **内存占用高**：浏览器堆内存很快上升，GC 频繁甚至卡死；
    - **视觉冗余**：屏幕像素有限，用户肉眼无法区分这么多细节点。

- **设计目标**
  - 在**不明显破坏趋势与关键形状**的前提下，将前端实际渲染点数压缩到**千级（1k～3k）**；
  - 支持多时间跨度、多图多指标共存的场景；
  - 显著降低前端 CPU 和内存占用，为复杂交互与 AI 能力留出性能空间。

---

### 二、整体方案：时间窗口聚合 + 自适应采样

整体思路是“**先按时间做粗聚合，再按形状做细采样**”：

- **第一层：时间窗口聚合（Time Window Aggregation）**
  - 按时间轴或数据点数量，将数据划分为多个窗口；
  - 在每个窗口内做 `min / max / avg / count` 等统计；
  - 起到**粗压缩 + 降噪**的作用。

- **第二层：自适应采样（Adaptive Sampling，以 LTTB 为主）**
  - 在第一层聚合后数据上，再执行 LTTB 等形状保持型采样算法；
  - 自动保留“形状变化最大”的点（峰值、谷值、拐点）；
  - 进一步把点数控制到前端可接受的范围。

示意流程（以 100 万点为例）：

- 原始数据：1,000,000 点  
- 时间窗口聚合：降到约 20,000 点  
- LTTB 自适应采样：再降到约 2,000 点  
- **最终前端实际只渲染 ~2,000 点**。

---

### 三、时间窗口聚合策略

#### 3.1 窗口大小选择原则（像素驱动）

核心思想：**用“图表像素宽度”反推窗口大小**。

设：

- 原始点数：\( N \)
- 图表宽度（像素）：\( W \)
- 希望每个像素最多承载 \( k \) 个数据点（通常 1～3）

则时间窗口（或等量窗口）的大小大致为：

\[
windowSize \approx \frac{N}{W \times k}
\]

示例：

- \( N = 100\,000 \)，\( W = 1000 \)，\( k = 2 \)  
- \( windowSize \approx 100000 / (1000 \times 2) = 50 \)

**意义**：确保“最终有效点数 ≈ 像素数 × 常数”，从根本上避免“像素不足而点数过多”的过度绘制。

#### 3.2 常用聚合方式

- **Min/Max 聚合**
  - 每个窗口内计算：`minValue`, `maxValue`, `avgValue`, `timestampRange` 等；
  - 绘图时至少保留 `min` 和 `max`（可选 `avg` 作为中枢线）；
  - 能保留波动区间，适合监控类曲线（请求耗时、QPS、错误率等）。

- **均值聚合（Mean）**
  - 每个窗口输出一个“平均点”；
  - 适合对极值不敏感、只看整体走势的场景。

- **事件/峰值保留聚合**
  - 窗口内若存在告警点或明显峰值，强制保留这些点；
  - 其余点参与均值或其他统计计算；
  - 确保关键业务事件不会被聚合抹平。

#### 3.3 实现位置与接口建议

- **实现位置**
  - 推荐在**后端或 Web Worker** 中执行窗口聚合，避免阻塞浏览器主线程；
  - 对输入数据先按 `timestamp` 排序，然后按 `windowSize` 切片聚合。

- **接口示例**

前端请求（伪代码）：

```json
{
  "metric": "qps",
  "startTime": 1690000000000,
  "endTime": 1690003600000,
  "maxPoints": 2000,
  "aggMode": "minmax"
}
```

后端响应（伪代码）：

```json
{
  "points": [
    { "t": 1690000000000, "min": 10, "max": 20, "avg": 15 },
    { "t": 1690000050000, "min": 12, "max": 25, "avg": 18 }
  ]
}
```

前端可以根据图表组件类型，决定使用 `min/max/avg` 中的哪一种（或多条系列叠加）。

---

### 四、自适应采样策略（以 LTTB 为例）

#### 4.1 为什么需要“自适应”？

- **固定间隔采样的缺点**：
  - 剧烈变化区域：峰值/谷值容易被丢掉；
  - 平稳区域：依然留下大量“长得一样”的点，浪费性能。

自适应采样的目标是：**根据数据形状差异自动决定哪些点必须保留**，优先保留对曲线形状影响最大的点。

#### 4.2 LTTB 的核心思想

LTTB（Largest Triangle Three Buckets）主要流程：

1. 固定保留首尾两个点；
2. 将中间点划分为若干个等量桶（buckets）；
3. 对于每个桶：
   - 取上一个已选中的点作为 A；
   - 计算下一个桶的平均点作为 C；
   - 枚举当前桶的所有候选点 B，计算三角形 △ABC 的面积；
   - 选出面积最大的 B 作为该桶代表点；
4. 重复步骤 3，直到处理完所有桶。

**面积含义**：

- 三角形面积越大，说明该点相较前后点“突出来”越明显；
- 通常意味着这里存在拐点、峰值或明显的局部变化。

因此，LTTB 倾向于在**变化剧烈区域**保留更多点，在**平滑区域**自然丢弃多余点。

#### 4.3 与时间窗口聚合的组合策略

推荐使用**两级策略**：

- **第一级：时间窗口聚合（按时间/数量粗压缩）**
  - 将原始几十万/上百万点压到几万点；
  - 同时对局部噪声进行平滑。

- **第二级：LTTB 自适应采样（按形状细采样）**
  - 在几万点级别的数据上，再按目标点数（如 1500～2000）执行 LTTB；
  - 输出千级点数，用于前端渲染。

这样既保证了整体趋势与高度变化的保真，又能把渲染成本控制在可接受范围。

---

### 五、典型使用场景

#### 5.1 系统监控大盘

- **场景**：接口 QPS、响应时间、错误率、CPU/内存占用、磁盘 IO 等监控曲线；
- **特点**：时间跨度长（1 小时～7 天），多图多指标同时展示；
- **策略**：
  - 后端根据当前时间范围和期望 `maxPoints` 做时间窗口聚合；
  - 对聚合结果执行 LTTB 采样，输出千级点数；
  - 前端只需渲染下采样后的数据即可。

#### 5.2 用户行为与事件分析

- **场景**：PV/UV、转化率曲线、留存率曲线、事件触发频率等；
- **特点**：事件日志粒度细；活动/版本发布等关键时间点附近变化明显；
- **策略**：
  - 按固定时间粒度（如 1 分钟/5 分钟/15 分钟）聚合；
  - 对聚合后的时间序列再执行 LTTB；
  - 保证活动开始/结束、功能发布等关键时段的变化被清晰保留。

#### 5.3 预测与模型结果展示

- **场景**：时间序列预测曲线 vs 实际值、训练 loss 曲线、残差曲线等；
- **策略**：
  - 对训练过程的 loss 曲线做时间窗口聚合 + LTTB，保持整体收敛形状；
  - 对长时间预测结果，在历史段和预测段分别采样，重点保留预测边界附近的形状。

---

### 六、性能与内存收益分析

#### 6.1 渲染与计算性能

以单条曲线为例：

- 原始数据：1,000,000 点；
- 时间窗口聚合：窗口大小约 50 → 20,000 点；
- LTTB 采样：目标 2,000 点。

收益：

- 渲染复杂度近似从 O(1,000,000) 降为 O(2,000)；
- 图表内部数据结构与绘图指令数量按比例缩减；
- 前端 JS 运算、布局、绘制的总体耗时显著下降。

#### 6.2 内存与带宽

- 原始 1,000,000 点的 JSON 体积与 JS 数组内存消耗远大于 2,000 点；
- 后端在接口层面只返回采样后的数据，可显著降低网络传输与序列化开销；
- 前端内存占用降低，减少 GC 频率与卡顿风险。

#### 6.3 交互体验

- **缩放 / 平移**：
  - 可根据当前视图范围重新请求对应时间段的采样数据；
  - 单次数据更新通常在 50～100ms 以内，交互流畅。

- **多图联动**：
  - 多个图表共用相同时间范围与采样策略，更新一致；
  - 每个图表点数可控，整个页面在多图联动时仍保持较高帧率。

---

### 七、接入与实现建议

#### 7.1 后端实现建议

- 在查询层根据前端参数（时间范围、图表宽度、maxPoints 等）动态计算：
  - 时间窗口大小 `windowSize`；
  - LTTB 目标点数 `targetPoints`。
- 将时间窗口聚合和 LTTB 封装为可复用的工具模块：
  - 便于在不同指标、不同服务中复用相同策略；
  - 统一维护性能与精度权衡。

#### 7.2 前端实现建议

- 为折线图封装统一的数据获取函数，如：
  - 根据 `chartWidth` 和设备性能推算合适的 `maxPoints`；
  - 向后端请求“已采样好的曲线数据”；
  - 将结果直接交给图表库（ECharts、AntV、Chart.js 等）渲染。
- 对于不方便改造后端的场景，可在 Web Worker 中：
  - 先做前端层面的时间窗口聚合；
  - 再做本地 LTTB 采样；
  - 避免主线程被大规模运算阻塞。

#### 7.3 渐进式接入策略

1. 第一阶段：仅引入**时间窗口平均聚合**，快速缓解最严重的性能问题；
2. 第二阶段：在关键大盘上增加 LTTB 自适应采样，提升形状保真度；
3. 第三阶段：根据业务场景，对不同图表配置差异化的采样策略和参数。

---

### 八、小结

- **时间窗口聚合**：从“时间/数量维度”粗压缩数据，按像素驱动窗口大小，先解决数据量级过大的问题；
- **自适应采样（LTTB）**：从“形状维度”精细选择关键点，自动保留峰值、谷值和拐点；
- **两者组合**：可在百万级时间序列场景中，将前端渲染控制在千级点数，同时视觉上尽量接近原始曲线。

在实际工程中，可以结合业务对“精度 vs 性能”的要求，通过配置化方式调整窗口大小与采样目标点数，在不同页面、不同图表之间实现灵活的性能优化策略。


