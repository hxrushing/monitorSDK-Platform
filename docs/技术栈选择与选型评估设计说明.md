# 技术栈选择与选型评估设计说明

## 📋 概述

本文档旨在说明 SDK 平台在开发过程中选择特定技术栈（如 React、Fetch、LTTB、SSE 等）的核心原因，并分享一套通用的技术选型评估模型，帮助团队在未来的决策中保持科学性与一致性。

---

## 一、核心技术栈选择原因

### 1.1 前端框架：React + Ant Design
- **原因**：
    - **生态与人才**：React 拥有最广泛的社区支持和成熟的第三方库（如 `web-vitals` 的 React 适配）。
    - **组件化思维**：埋点后台涉及大量复杂的配置页面（如事件定义、报警规则），React 的声明式组件化能显著提升开发效率。
    - **性能上限**：通过 `React.memo`、`useMemo` 以及 `Concurrent Mode`（并发模式），能够很好地支撑高频数据刷新的监控大盘。
- **选型结论**：**高效率 + 强性能控制。**

### 1.2 数据上报：Fetch API + AbortController
- **原因**：
    - **现代性**：原生支持 Promise，代码结构比传统的 `XMLHttpRequest` 更简洁、易读。
    - **超时控制**：通过 `AbortController` 能够实现精细化的请求超时管理，这是埋点 SDK 防止阻塞主线程的关键。
    - **流式处理**：虽然目前主要用 JSON，但 Fetch 的 `ReadableStream` 特性为未来可能的流式上报留下了扩展空间。
- **选型结论**：**轻量级 + 现代异步编程范式。**

### 1.3 可视化算法：LTTB (Largest-Triangle-Three-Buckets)
- **原因**：
    - **视觉保真**：传统的“等间隔采样”容易丢失性能毛刺（峰值/谷值）。LTTB 专门为折线图设计，通过三角形面积计算，优先保留“对曲线形状贡献最大”的点。
    - **性能收益**：将百万级数据压缩到千级渲染，在不牺牲视觉趋势的前提下，使前端渲染性能提升了 100 倍以上。
- **选型结论**：**极致性能与数据保真度的最优平衡。**

### 1.4 AI 总结：OpenAI + tiktoken
- **原因**：
    - **理解能力**：OpenAI 的 GPT 系列模型在数据归因分析和自然语言建议生成方面具有显著优势。
    - **成本控制**：引入 `tiktoken` 库进行精准的 Token 计数，实现了“分批总结 -> 递归提炼”的策略，避免了长上下文导致的高额费用。
- **选型结论**：**领先的智能水平 + 精细化的成本管控。**

### 1.5 实时通信：Server-Sent Events (SSE)
- **原因**：
    - **轻量级**：相比 WebSocket，SSE 基于标准 HTTP 协议，实现更简单，且原生支持自动重连。
    - **单向需求**：AI 总结的进度推送是典型的“服务端向客户端”单向通信场景，SSE 完全满足需求且开销更小。
- **选型结论**：**按需选型，不为过度设计买单。**

---

## 二、技术选型评估模型 (The 5-Dimension Model)

在进行任何技术选型时，我们遵循以下五个维度的综合评估：

### 2.1 业务匹配度 (Business Alignment)
- **核心问**：该技术是否直接解决了当前业务最痛点？
- **案例**：选择 LTTB 而不是普通采样，是因为“不丢失异常峰值”对性能监控至关重要。

### 2.2 性能与开销 (Performance & Overhead)
- **核心问**：该技术带来的性能收益是否远大于其自身的引入开销（如包体积、CPU 占用）？
- **案例**：选择 Fetch 而不是 Axios，是为了减少 SDK 的产物体积（Axios 约 10KB+，Fetch 是浏览器原生）。

### 2.3 生态与稳定性 (Ecosystem & Stability)
- **核心问**：社区是否活跃？是否有大厂背书？是否有完善的文档和填坑记录？
- **案例**：选择 React 确保了在遇到复杂可视化交互问题时，总能找到成熟的解决方案。

### 2.4 可维护性与可扩展性 (Maintainability)
- **核心问**：该技术是否符合团队的技术栈底色？是否容易进行二次开发或降级？
- **案例**：在 `AIService` 中增加准确的 Token 估算和分批处理，就是为了增强 AI 链路在面对超大规模数据时的可维护性。

### 2.5 学习与接入成本 (Learning Curve)
- **核心问**：新成员上手需要多久？接入已有系统是否需要大规模重构？
- **案例**：设计“可插拔探针 SDK”，就是为了让其他项目在接入时只需一行代码，学习成本几乎为零。

---

## 三、技术决策的“黄金法则”

1.  **不追求“最新”，追求“最合适”**：如 SSE 与 WebSocket 的选择。
2.  **原生优先，三方为辅**：如优先使用 `CompressionStream` 原生压缩，减少依赖包。
3.  **为“最坏情况”设计**：所有选型必须配套降级方案（如 AI 失败回退到基础统计总结，Fetch 失败进入离线存储）。
4.  **数据驱动选型**：在决定引入 LTTB 之前，我们进行了 10 万点对比 1000 点的渲染耗时测试，用数据证明选型的价值。

---

## 四、总结

技术选型不是一次性的博弈，而是一个动态演进的过程。本项目的技术栈选择（React、Fetch、LTTB 等）均服务于一个终极目标：**在不干扰业务性能的前提下，提供最精准、最智能的数据洞察。**

通过科学的评估模型，我们确保了每一项引入的技术都能为业务创造真实的价值，而不是技术人员的“自嗨”。

