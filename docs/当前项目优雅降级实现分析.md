# 当前项目优雅降级实现分析

## 概述

本文档基于项目中**现有的代码**，分析如何平衡性能与用户体验，以及如何处理不可恢复的错误。

## 一、性能与用户体验的平衡

### 1. Dashboard 组件中的错误处理示例

**位置**：`src/pages/Dashboard/index.tsx`

#### 示例1：使用 Promise.allSettled 避免全部失败

```typescript:58-128:src/pages/Dashboard/index.tsx
const fetchData = useCallback(async () => {
  // ...
  try {
    // 使用 Promise.allSettled 避免一个失败导致全部失败
    const results = await Promise.allSettled([
      apiService.getStats({...}),
      apiService.getDashboardOverview(selectedProjectId),
      apiService.getTopProjects({...})
    ]);
    
    // 处理统计查询结果
    if (results[0].status === 'fulfilled') {
      setStatsData(results[0].value);
    } else {
      console.error('获取统计数据失败:', results[0].reason);
      message.warning('获取统计数据失败，可能是数据量过大，请缩小查询范围');
    }
    
    // 处理概览数据
    if (results[1].status === 'fulfilled') {
      setOverview(results[1].value);
    } else {
      console.error('获取概览数据失败:', results[1].reason);
      if (results[1].reason?.code === 'ECONNABORTED') {
        message.warning('获取概览数据超时，可能是数据量过大');
      }
    }
    
    // 处理Top项目数据
    if (results[2].status === 'fulfilled') {
      setTopProjects(results[2].value);
    } else {
      console.error('获取Top项目数据失败:', results[2].reason);
    }
    
    // 如果所有请求都失败
    if (results.every(r => r.status === 'rejected')) {
      message.error('获取数据失败，请检查网络连接或缩小查询范围');
    }
  }
}, [dateRange, selectedProjectId]);
```

**平衡点分析：**

✅ **性能优化：**
- 使用 `Promise.allSettled` 并行请求，不阻塞其他请求
- 即使某个请求失败，其他成功的请求仍能显示数据
- 错误处理是异步的，不阻塞UI渲染

✅ **用户体验：**
- 部分数据失败时，仍能显示成功加载的数据
- 提供明确的错误提示，告诉用户可能的原因（数据量过大）
- 区分不同类型的错误（超时 vs 其他错误）

#### 示例2：Worker 降级处理

```typescript:44-188:src/pages/Dashboard/index.tsx
// 使用 Worker 处理大数据采样
const { postMessage: sampleData, isProcessing: isSampling } = useDataSamplingWorker<any[]>(
  (result) => {
    setSampledChartData(result);
  },
  {
    onError: (error) => {
      console.error('[Dashboard] Worker 采样失败:', error);
      // Worker 失败时，会在 useEffect 中自动回退到同步方式
    }
  }
);

// 使用 Worker 进行大数据采样，避免阻塞主线程
useEffect(() => {
  if (chartData.length === 0) {
    setSampledChartData([]);
    return;
  }

  // 数据量小于阈值时，直接使用原数据（不采样）
  if (chartData.length <= 500) {
    setSampledChartData(chartData);
    return;
  }

  // 数据量大于阈值时，使用 Worker 进行采样
  // 如果 Worker 失败，会在 onError 中处理，这里使用 try-catch 作为额外保护
  try {
    sampleData({
      type: 'adaptive',
      payload: { ... }
    });
  } catch (error) {
    // Worker 不可用时，回退到同步方式
    console.warn('[Dashboard] Worker 不可用，使用同步采样:', error);
    const fallbackResult = adaptiveChartSampling(chartData, 500, 1000, 'date', 'value', 'type');
    setSampledChartData(fallbackResult);
  }
}, [chartData, sampleData]);
```

**平衡点分析：**

✅ **性能优化：**
- 大数据量时使用 Worker，避免阻塞主线程
- 小数据量时直接处理，避免 Worker 开销
- Worker 失败时立即回退到同步方式，不等待

✅ **用户体验：**
- 显示加载状态（`chartLoading`），让用户知道正在处理
- Worker 失败时自动降级，用户无感知
- 保证功能可用性，即使性能降级

### 2. HTTP 拦截器中的错误处理

**位置**：`src/utils/http.ts`

```typescript:25-60:src/utils/http.ts
// 响应拦截器
instance.interceptors.response.use(
  response => response.data,
  async (error: AxiosError) => {
    const config = error.config as (InternalAxiosRequestConfig & { __retryCount?: number }) | undefined

    // 401 直接处理，不重试
    const status = error?.response?.status
    if (status === 401) {
      localStorage.removeItem('token')
      localStorage.removeItem('userInfo')
      if (window.location.pathname !== '/login') {
        window.location.href = '/login'
      }
      return Promise.reject(error)
    }

    // 判断是否需要重试：网络错误/无响应，或 5xx/429
    const shouldRetry =
      !error.response ||
      (status !== undefined && (status >= 500 || status === 429))

    if (config && shouldRetry) {
      config.__retryCount = config.__retryCount || 0
      if (config.__retryCount < MAX_RETRIES) {
        config.__retryCount += 1
        const delay = BASE_DELAY * Math.pow(2, config.__retryCount - 1) + Math.random() * 200
        await sleep(delay)
        return instance.request(config)
      }
    }

    console.error('API Error:', error)
    return Promise.reject(error)
  }
)
```

**平衡点分析：**

✅ **性能优化：**
- 指数退避重试，避免频繁请求
- 只对可恢复的错误重试（网络错误、5xx、429）
- 401 错误不重试，立即处理

✅ **用户体验：**
- 自动重试，用户无需手动操作
- 401 错误立即跳转登录，避免无效重试
- 重试失败后抛出错误，让组件层处理

## 二、不可恢复错误的处理

### 示例：RouteErrorBoundary 处理路由错误

**位置**：`src/components/RouteErrorBoundary.tsx`

#### 1. 404 错误（资源不存在）

```typescript:17-31:src/components/RouteErrorBoundary.tsx
if (error.status === 404) {
  return (
    <Result
      status="404"
      title="404"
      subTitle="抱歉，您访问的页面不存在。"
      extra={
        <Link to="/app/dashboard">
          <Button type="primary" icon={<HomeOutlined />}>
            返回首页
          </Button>
        </Link>
      }
    />
  );
}
```

**处理策略：**
- ✅ 这是**不可恢复的错误**（资源不存在）
- ✅ 提供明确的错误提示
- ✅ 提供返回首页的选项，让用户继续使用应用

#### 2. 500 错误（服务器错误）

```typescript:34-68:src/components/RouteErrorBoundary.tsx
if (error.status === 500) {
  return (
    <Result
      status="500"
      title="500"
      subTitle="服务器出现了错误，请稍后再试。"
      extra={[
        <Link to="/app/dashboard" key="home">
          <Button type="primary" icon={<HomeOutlined />}>
            返回首页
          </Button>
        </Link>,
        <Button
          key="reload"
          icon={<ReloadOutlined />}
          onClick={() => window.location.reload()}
        >
          刷新页面
        </Button>,
      ]}
    >
      {process.env.NODE_ENV === 'development' && error.data && (
        <div style={{ marginTop: 16, padding: 16, background: '#f5f5f5', borderRadius: 4 }}>
          <details>
            <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
              错误详情（开发环境）
            </summary>
            <pre style={{ marginTop: 8, whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
              {JSON.stringify(error.data, null, 2)}
            </pre>
          </details>
        </div>
      )}
    </Result>
  );
}
```

**处理策略：**
- ✅ 这是**可能可恢复的错误**（服务器临时错误）
- ✅ 提供两个选项：返回首页（继续使用）或刷新页面（重试）
- ✅ 开发环境显示详细错误信息，便于调试

#### 3. JavaScript 错误（渲染错误）

```typescript:88-124:src/components/RouteErrorBoundary.tsx
// JavaScript错误或其他错误
const errorMessage = error instanceof Error ? error.message : '发生了未知错误';

return (
  <Result
    status="500"
    title="错误"
    subTitle={errorMessage}
    extra={[
      <Link to="/app/dashboard" key="home">
        <Button type="primary" icon={<HomeOutlined />}>
          返回首页
        </Button>
      </Link>,
      <Button
        key="reload"
        icon={<ReloadOutlined />}
        onClick={() => window.location.reload()}
      >
        刷新页面
      </Button>,
    ]}
  >
    {process.env.NODE_ENV === 'development' && error instanceof Error && (
      <div style={{ marginTop: 16, padding: 16, background: '#f5f5f5', borderRadius: 4 }}>
        <details>
          <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
            错误详情（开发环境）
          </summary>
          <pre style={{ marginTop: 8, whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
            {error.stack || error.toString()}
          </pre>
        </details>
      </div>
    )}
  </Result>
);
```

**处理策略：**
- ✅ 这是**不可恢复的错误**（代码错误）
- ✅ 提供返回首页和刷新页面的选项
- ✅ 开发环境显示错误堆栈，生产环境隐藏技术细节

### 示例：ErrorBoundary 处理组件渲染错误

**位置**：`src/components/ErrorBoundary.tsx`

```typescript:36-47:src/components/ErrorBoundary.tsx
componentDidCatch(error: Error, errorInfo: ErrorInfo) {
  // 记录错误到错误报告服务
  console.error('ErrorBoundary捕获到错误:', error, errorInfo);
  
  // 这里可以发送错误到监控服务
  // errorReportingService.logError(error, errorInfo);
  
  this.setState({
    error,
    errorInfo,
  });
}
```

**处理策略：**
- ✅ 错误记录是**同步的**（`console.error`），但错误上报可以异步
- ✅ 立即更新状态，显示降级UI
- ✅ 错误上报不阻塞UI渲染（注释中的 `errorReportingService.logError` 应该是异步的）

```typescript:49-59:src/components/ErrorBoundary.tsx
handleReset = () => {
  this.setState({
    hasError: false,
    error: undefined,
    errorInfo: undefined,
  });
};

handleGoHome = () => {
  window.location.href = '/app/dashboard';
};
```

**恢复选项：**
- ✅ **重试**：重置错误状态，尝试重新渲染（适用于临时错误）
- ✅ **返回首页**：跳转到安全页面（适用于不可恢复的错误）

## 三、总结：性能与用户体验的平衡策略

### 1. 性能优化策略

| 策略 | 实现位置 | 效果 |
|------|---------|------|
| **并行请求** | Dashboard `Promise.allSettled` | 多个请求并行，不互相阻塞 |
| **Worker 降级** | Dashboard Worker 处理 | Worker 失败时回退到同步方式 |
| **指数退避重试** | HTTP 拦截器 | 避免频繁请求，减少服务器压力 |
| **错误分类** | HTTP 拦截器 | 只对可恢复的错误重试 |

### 2. 用户体验优化策略

| 策略 | 实现位置 | 效果 |
|------|---------|------|
| **部分数据展示** | Dashboard `Promise.allSettled` | 部分失败时仍显示成功的数据 |
| **友好错误提示** | RouteErrorBoundary | 根据错误类型显示不同的提示 |
| **降级选项** | ErrorBoundary | 提供重试和返回首页选项 |
| **加载状态** | Dashboard `chartLoading` | 显示处理进度，让用户知道正在处理 |

### 3. 不可恢复错误的处理

| 错误类型 | 处理方式 | 恢复选项 |
|---------|---------|---------|
| **404 错误** | 显示404页面 | 返回首页 |
| **500 错误** | 显示500页面 | 返回首页 或 刷新页面 |
| **渲染错误** | ErrorBoundary 捕获 | 重试 或 返回首页 |
| **401 错误** | HTTP 拦截器处理 | 跳转登录页面 |

## 四、关键设计原则

1. **快速失败，优雅降级**：错误发生时立即显示降级UI，不等待错误处理完成
2. **部分可用优于完全失败**：使用 `Promise.allSettled`，部分失败时仍显示成功的数据
3. **自动降级优于手动操作**：Worker 失败时自动回退到同步方式
4. **明确错误提示**：根据错误类型提供不同的提示和恢复选项
5. **性能不阻塞用户体验**：错误处理是异步的，不阻塞UI渲染

