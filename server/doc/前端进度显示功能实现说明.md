# 前端进度显示功能实现说明

## 功能概述

实现了 AI 总结生成过程的实时进度显示功能，用户可以实时查看总结生成的各个阶段和进度。

## 实现方案

### 技术选型

- **后端**：内存存储任务进度（生产环境建议使用 Redis）
- **前端**：Server-Sent Events (SSE) 实时推送进度
- **通信方式**：Server-Sent Events + RESTful API（降级方案）

### 为什么选择 SSE？

1. **实时性好**：进度更新立即推送到前端，无需等待轮询间隔
2. **服务器推送**：服务器主动推送，减少不必要的请求
3. **实现简单**：比 WebSocket 更简单，不需要双向通信
4. **自动重连**：浏览器原生支持自动重连
5. **降级方案**：如果 SSE 不可用，自动降级到轮询

## 实现细节

### 1. 后端实现

#### 1.1 任务进度数据结构

```typescript
interface SummaryTaskProgress {
  taskId: string;              // 任务 ID
  userId: string;              // 用户 ID
  status: 'pending' | 'collecting' | 'generating' | 'sending' | 'completed' | 'failed';
  progress: number;            // 0-100
  currentStep: string;          // 当前步骤描述
  totalProjects: number;        // 总项目数
  processedProjects: number;   // 已处理项目数
  error?: string;               // 错误信息（如果有）
  startedAt: number;            // 开始时间
  updatedAt: number;            // 更新时间
}
```

#### 1.2 进度跟踪机制

在 `SummaryService` 中添加了：

- **任务进度存储**：使用 `Map<string, SummaryTaskProgress>` 存储任务进度
- **进度更新方法**：`updateProgress()` 方法用于更新任务进度
- **进度查询方法**：`getTaskProgress()` 方法用于查询任务进度
- **自动清理机制**：定期清理 1 小时前的过期任务

#### 1.3 进度更新点

在 `generateAndSendSummary` 方法中添加了多个进度更新点：

1. **准备阶段** (0-5%)：初始化任务
2. **获取邮箱** (5-10%)：获取用户邮箱
3. **获取项目列表** (10-15%)：获取要处理的项目
4. **收集数据** (15-65%)：收集每个项目的数据
   - 每个项目约 50% / 项目总数 的进度
5. **生成总结** (65-85%)：使用 AI 生成总结
6. **准备邮件** (85-90%)：渲染 HTML
7. **发送邮件** (90-100%)：发送邮件

### 2. API 端点

#### 2.1 启动任务

**POST** `/api/ai-summary/send-now`

**响应：**
```json
{
  "success": true,
  "taskId": "uuid-string",
  "message": "总结生成任务已启动，请查询进度"
}
```

**变更：**
- 改为异步执行，立即返回 `taskId`
- 不等待任务完成

#### 2.2 Server-Sent Events 进度推送（主要方式）

**GET** `/api/ai-summary/progress/:taskId/stream?token=xxx`

**特点：**
- 使用 Server-Sent Events (SSE) 实时推送进度
- 连接保持打开，服务器主动推送更新
- 每 30 秒发送心跳保持连接
- 任务完成或失败时自动关闭连接

**响应格式：**
```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

data: {"success":true,"data":{"taskId":"...","status":"generating",...}}

data: {"success":true,"data":{"taskId":"...","status":"generating",...}}

: heartbeat

event: close
data: {"success":true,"data":{"taskId":"...","status":"completed",...}}
```

**安全：**
- 通过 URL 参数传递 token（EventSource 不支持自定义 headers）
- 验证 token 有效性
- 验证任务属于当前用户

#### 2.3 查询进度（降级方案）

**GET** `/api/ai-summary/progress/:taskId`

**响应：**
```json
{
  "success": true,
  "data": {
    "taskId": "uuid-string",
    "userId": "user-id",
    "status": "generating",
    "progress": 65,
    "currentStep": "正在使用 AI 生成总结...",
    "totalProjects": 5,
    "processedProjects": 5,
    "startedAt": 1234567890,
    "updatedAt": 1234567890
  }
}
```

**用途：**
- SSE 连接失败时的降级方案
- 兼容性查询接口

**安全：**
- 需要认证（Bearer Token）
- 验证任务属于当前用户

### 3. 前端实现

#### 3.1 状态管理

```typescript
const [progress, setProgress] = useState<SummaryProgress | null>(null);
const eventSourceRef = useRef<EventSource | null>(null);
```

#### 3.2 SSE 连接逻辑

```typescript
const connectProgressStream = (taskId: string) => {
  // 获取 token
  const token = localStorage.getItem('token');
  const url = `${apiBaseUrl}/ai-summary/progress/${taskId}/stream?token=${token}`;
  
  // 创建 EventSource
  const eventSource = new EventSource(url);

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    setProgress(data.data);
    
    // 任务完成或失败时关闭连接
    if (data.data.status === 'completed' || data.data.status === 'failed') {
      eventSource.close();
    }
  };

  eventSource.onerror = (error) => {
    // SSE 连接失败，降级到轮询
    eventSource.close();
    fallbackToPolling(taskId);
  };
};
```

#### 3.3 降级方案

如果 SSE 连接失败，自动降级到轮询：

```typescript
const fallbackToPolling = async (taskId: string) => {
  const interval = setInterval(async () => {
    const result = await apiService.getSummaryProgress(taskId);
    setProgress(result.data);
    
    if (result.data.status === 'completed' || result.data.status === 'failed') {
      clearInterval(interval);
    }
  }, 2000);
};
```

#### 3.3 UI 组件

- **进度条**：使用 Ant Design 的 `Progress` 组件
- **状态显示**：显示当前状态和步骤
- **项目进度**：显示已处理/总项目数
- **错误提示**：如果失败，显示错误信息
- **成功提示**：完成后显示成功消息

## 用户体验

### 进度显示内容

1. **进度条**：0-100% 的进度可视化
2. **当前状态**：pending / collecting / generating / sending / completed / failed
3. **当前步骤**：具体的操作描述
4. **项目进度**：X / Y 个项目（如果有多个项目）
5. **错误信息**：如果失败，显示详细错误

### 状态颜色

- **进行中**：蓝色 (#1890ff)
- **成功**：绿色 (#52c41a)
- **失败**：红色 (#ff4d4f)

## 性能考虑

### 内存管理

- 任务进度存储在内存中
- 自动清理 1 小时前的过期任务
- 生产环境建议使用 Redis 存储

### SSE 连接管理

- 每个任务一个 SSE 连接
- 任务完成后自动关闭连接
- 组件卸载时清理连接
- 每 30 秒发送心跳保持连接
- 连接断开时自动降级到轮询

### 降级方案

- SSE 连接失败时自动降级到轮询
- 轮询频率：每 2 秒一次
- 任务完成后立即停止轮询

## 错误处理

1. **任务不存在**：返回 404，关闭 SSE 连接
2. **权限不足**：返回 403，关闭 SSE 连接
3. **SSE 连接错误**：自动降级到轮询模式
4. **网络错误**：降级到轮询，继续尝试
5. **任务失败**：显示错误信息，关闭连接

## 后续优化建议

### 1. 使用 Redis 存储进度（生产环境）

```typescript
// 使用 Redis 存储任务进度
await redis.setex(`summary:progress:${taskId}`, 3600, JSON.stringify(progress));

// 使用 Redis Pub/Sub 推送进度更新
await redis.publish(`summary:progress:${taskId}`, JSON.stringify(progress));
```

### 2. 优化 SSE 连接管理

- 使用连接池管理多个 SSE 连接
- 实现连接重试机制
- 添加连接状态监控

### 3. 添加 WebSocket 支持（可选）

对于需要双向通信的场景，可以考虑使用 WebSocket，但 SSE 已经足够满足当前需求。

## 测试建议

### 1. 测试正常流程

1. 点击"立即发送测试"
2. 观察进度条更新
3. 验证各个阶段的进度显示
4. 确认完成后显示成功消息

### 2. 测试错误场景

1. 模拟网络错误
2. 模拟任务失败
3. 验证错误信息显示

### 3. 测试多项目场景

1. 配置多个项目
2. 验证项目进度显示
3. 确认进度计算正确

## 总结

前端进度显示功能已成功实现，使用 Server-Sent Events (SSE) 提供实时进度更新：

- ✅ **实时推送**：使用 SSE 实时推送进度，无需轮询
- ✅ **清晰的状态提示**：显示当前处理阶段和详细步骤
- ✅ **自动降级**：SSE 失败时自动降级到轮询模式
- ✅ **友好的错误处理**：失败时显示具体错误信息
- ✅ **自动清理机制**：任务完成后自动关闭连接
- ✅ **心跳保持**：定期发送心跳保持连接活跃

用户现在可以实时了解总结生成的进度，获得更好的用户体验。

