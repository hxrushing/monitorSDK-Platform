# 百万级数据性能优化说明

## 🔧 已完成的优化

### 1. 前端超时配置优化

**文件**: `src/utils/http.ts`, `src/services/api.ts`

- **默认超时**: 从10秒增加到30秒
- **统计查询超时**: 60秒（大数据量查询）
- **概览查询超时**: 30秒
- **Top项目查询超时**: 30秒

### 2. 错误处理优化

**文件**: `src/pages/Dashboard/index.tsx`

- 使用 `Promise.allSettled` 替代 `Promise.all`，避免一个请求失败导致全部失败
- 添加详细的错误提示
- 区分超时错误和其他错误，给出不同的提示
- 添加加载提示，提升用户体验

### 3. 后端查询优化

**文件**: `server/src/services/statsService.ts`

- 优化平均停留时间查询，使用更简单的SQL
- 减少子查询嵌套，提升查询性能

### 4. 数据库索引优化

**文件**: `server/optimize_database_indexes.sql`

创建了以下索引：
- `idx_project_timestamp`: project_id + timestamp（最常用）
- `idx_project_event`: project_id + event_name（事件分析）
- `idx_date`: DATE(timestamp)（日期查询）
- `idx_user_id`: user_id（UV统计）
- `idx_project_user_timestamp`: project_id + user_id + timestamp（用户行为分析）

---

## 📋 使用步骤

### 步骤1：优化数据库索引（重要！）

```bash
# 执行索引优化脚本
mysql -u root -p sdk-platform < server/optimize_database_indexes.sql
```

**或者手动执行**：
```sql
USE `sdk-platform`;

-- 创建复合索引
CREATE INDEX idx_project_timestamp ON events(project_id, timestamp);
CREATE INDEX idx_project_event ON events(project_id, event_name);
CREATE INDEX idx_date ON events((DATE(timestamp)));
CREATE INDEX idx_user_id ON events(user_id);

-- 分析表（更新统计信息）
ANALYZE TABLE events;
```

### 步骤2：重启前端服务

```bash
# 前端会自动重新编译
# 如果使用热更新，会自动生效
```

### 步骤3：测试性能

1. 打开Dashboard页面
2. 选择性能测试项目（perf-test-project）
3. 观察加载时间和是否超时

---

## 🎯 性能优化效果

### 优化前
- ❌ 默认超时10秒，大数据量查询经常超时
- ❌ 一个请求失败导致整个页面数据加载失败
- ❌ 没有索引，查询需要全表扫描
- ❌ 复杂子查询，执行时间长

### 优化后
- ✅ 超时时间增加到30-60秒，支持大数据量查询
- ✅ 使用Promise.allSettled，部分失败不影响其他数据
- ✅ 添加索引，查询速度提升10-100倍
- ✅ 简化SQL查询，减少执行时间

---

## 📊 预期性能指标

### 查询性能（100万数据）

| 查询类型 | 优化前 | 优化后（有索引） | 提升 |
|---------|--------|-----------------|------|
| 统计查询（30天） | > 10秒（超时） | < 2秒 | 5倍+ |
| 概览查询（今日） | > 10秒（超时） | < 1秒 | 10倍+ |
| Top项目查询 | > 10秒（超时） | < 1秒 | 10倍+ |

### 索引效果

- **无索引**: 全表扫描，100万数据需要扫描所有行
- **有索引**: 使用索引快速定位，只扫描相关行
- **性能提升**: 10-100倍（取决于数据分布）

---

## 🔍 进一步优化建议

### 1. 如果查询仍然很慢

**检查索引是否生效**：
```sql
EXPLAIN SELECT 
    DATE(timestamp) as date,
    COUNT(*) as pv,
    COUNT(DISTINCT user_id) as uv
FROM events
WHERE project_id = 'perf-test-project'
    AND DATE(timestamp) BETWEEN '2024-01-01' AND '2024-01-30'
GROUP BY DATE(timestamp);
```

查看 `key` 列，应该显示使用了 `idx_project_timestamp` 索引。

### 2. 如果数据量继续增长（> 1000万）

**考虑分表或分区**：
```sql
-- 按月分区
ALTER TABLE events PARTITION BY RANGE (YEAR(timestamp) * 100 + MONTH(timestamp)) (
    PARTITION p202401 VALUES LESS THAN (202402),
    PARTITION p202402 VALUES LESS THAN (202403),
    -- ...
);
```

### 3. 添加查询缓存

对于频繁查询的数据，可以使用Redis缓存：
- 今日概览数据：缓存5分钟
- 统计查询：缓存1分钟
- Top项目：缓存5分钟

### 4. 限制查询范围

在前端添加提示，建议用户：
- 查询范围不超过30天
- 大数据量项目使用更短的时间范围

---

## 🐛 故障排查

### 问题1：仍然超时

**可能原因**：
1. 索引未创建
2. 数据量过大（> 1000万）
3. 服务器性能不足

**解决方法**：
1. 检查索引：`SHOW INDEX FROM events;`
2. 缩小查询范围（减少天数）
3. 优化服务器配置

### 问题2：索引创建失败

**可能原因**：
- MySQL版本不支持某些语法
- 表被锁定

**解决方法**：
```sql
-- 检查MySQL版本
SELECT VERSION();

-- MySQL 5.7+ 支持函数索引
-- 如果版本较低，使用普通索引：
CREATE INDEX idx_timestamp ON events(timestamp);
```

### 问题3：查询变慢

**可能原因**：
- 索引未更新
- 数据分布不均匀

**解决方法**：
```sql
-- 更新统计信息
ANALYZE TABLE events;

-- 重建索引
ALTER TABLE events DROP INDEX idx_project_timestamp;
CREATE INDEX idx_project_timestamp ON events(project_id, timestamp);
```

---

## 📝 注意事项

1. **索引会占用存储空间**：每个索引大约占用表大小的10-20%
2. **索引会影响写入性能**：插入数据时需要更新索引，但查询性能提升远大于写入性能损失
3. **定期维护**：定期运行 `ANALYZE TABLE` 更新统计信息

---

## ✅ 验证优化效果

### 1. 检查索引
```sql
SHOW INDEX FROM events;
```

应该看到以下索引：
- idx_project_timestamp
- idx_project_event
- idx_date
- idx_user_id

### 2. 测试查询性能
```sql
-- 测试查询（应该 < 2秒）
SELECT 
    DATE(timestamp) as date,
    COUNT(*) as pv,
    COUNT(DISTINCT user_id) as uv
FROM events
WHERE project_id = 'perf-test-project'
    AND DATE(timestamp) BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND CURDATE()
GROUP BY DATE(timestamp)
ORDER BY date;
```

### 3. 查看执行计划
```sql
EXPLAIN SELECT ...;
```

查看 `key` 列，确认使用了索引。

---

**优化完成后，百万级数据的查询应该可以在2秒内完成！** 🚀

